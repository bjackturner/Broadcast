
! =============================================================================
!          consistent fluxes for DNC3 2D
! =============================================================================
!

!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of function_5p_dz in forward (tangent) mode (with options with!SliceDeadControl with!SliceDeadInstrs with!Stat
!icTaping):
!   variations   of useful results: func0 func1 func2 func3 func4
!                func5 func6 func7 func8 func9 func10 func11 func12
!                func13 func14 func15
!   with respect to varying inputs: w
!   RW status of diff variables: func0:out func1:out func2:out
!                w:in func3:out func4:out func5:out func6:out func7:out
!                func8:out func9:out func10:out func11:out func12:out
!                func13:out func14:out func15:out
! =============================================================================
!          consistent fluxes for DNC3 2D
! =============================================================================
!
SUBROUTINE FUNCTION_5P_DZ_D(func0, func0d, func1, func1d, func2, func2d&
& , func3, func3d, func4, func4d, func5, func5d, func6, func6d, func7, &
& func7d, func8, func8d, func9, func9d, func10, func10d, func11, func11d&
& , func12, func12d, func13, func13d, func14, func14d, func15, func15d, &
& w, wd, x0, y0, nx, ny, xc, yc, vol, volf, gh, cp, cv, prandtl, gam, &
& rgaz, cs, muref, tref, s_suth, im, jm)
  IMPLICIT NONE
!
! variables for dimension -----------------------------------------
  INTEGER :: im, jm, gh
! required arguments ----------------------------------------------
! thermo
  REAL*8, INTENT(IN) :: cp, cv, prandtl, gam, rgaz
! viscosity
  REAL*8, INTENT(IN) :: cs, muref, tref, s_suth
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1), INTENT(IN) :: x0
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1), INTENT(IN) :: y0
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 2), INTENT(IN) :: nx
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 2), INTENT(IN) :: ny
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: xc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: yc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: vol
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2), INTENT(IN) :: volf
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5), INTENT(IN) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5), INTENT(IN) :: wd
! Returned objects ------------------------------------------------
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func0
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func0d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func1
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func1d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func2
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func2d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func3
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func3d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func4
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func4d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func5
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func5d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func6
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func6d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func7
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func7d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func8
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func8d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func9
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func9d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func10
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func10d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func11
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func11d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func12
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func12d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func13
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func13d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func14
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func14d
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func15
  REAL*8, DIMENSION(im, jm, 5), INTENT(INOUT) :: func15d
! Non-required arguments -------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5) :: f, g
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velx
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velxd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: vely
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velyd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velz
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velzd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tloc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tlocd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: p
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: pd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: mu
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: mud
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: gradu, gradv, gradw, &
& gradmu
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: gradud, gradvd, gradwd
  INTEGER :: i, j, h
  REAL*8 :: nx_n, nx_s, nx_e, nx_o, volm1, ux, vx, wx, tx
  REAL*8 :: ny_n, ny_s, ny_e, ny_o, uy, vy, wy, ty
  REAL*8 :: val_n, val_s, val_e, val_o
  REAL*8 :: fxro1, fxro2, fxrou1, fxrou2, fxrov1, fxrov2, fxrow1, fxrow2&
& , fxroe1, fxroe2
  REAL*8 :: dissro1, dissro2, dissrou1, dissrou2, dissrov1, dissrov2, &
& dissrow1, dissrow2, dissroe1, dissroe2
  REAL*8 :: fvro1, fvro2, fvrou1, fvrou2, fvrov1, fvrov2, fvrow1, fvrow2&
& , fvroe1, fvroe2
  REAL*8 :: gvro1, gvro2, gvrou1, gvrou2, gvrov1, gvrov2, gvrow1, gvrow2&
& , gvroe1, gvroe2
  REAL*8 :: cpprandtl, mmu, lambda, uu, vv, ww, ro, rom1, htot, eloc, ec
  REAL*8 :: rod, rom1d, elocd, ecd
  REAL*8 :: predro1, predrou1, predrov1, predrow1, predroe1, eps2, eps4
  REAL*8 :: predro2, predrou2, predrov2, predrow2, predroe2, rspec
  REAL*8 :: divu2, vort2, dx, dy, dxm1, dym1, dxm2, dym2
  REAL*8 :: gui, gvi, gwi, gmui
  REAL*8 :: guid, gvid, gwid
  REAL*8 :: guj, gvj, gwj, gmuj
  REAL*8 :: gujd, gvjd, gwjd
  REAL*8 :: rhom, rhomr, rhoml, rhom1l, c2l, c2r, rr, r, u, ur, ul, vr, &
& vl, wr, wl, c2x, nx2, ny2
  REAL*8 :: ab, sq, ducros1, ducros2, k_sensor1, k_sensor2
  REAL*8 :: b1, b2, b3, b4, b5, c1, c2, c3, c4, c5, wiggle, denom, betas
  REAL*8 :: nxloc, nyloc, sn, invsn, sc1, sc2
  REAL*8 :: d1, d2
  REAL*8 :: c3d0, c3d1
  REAL*8 :: pw, ct0, ct1, ct2, cvm1
  REAL*8 :: coef, omrr, test, diffro, diffrou, diffrov, diffrow, diffroe&
& , v
  REAL*8 :: half, one, zero, two, twothird, fourth, twelfth
  REAL*8 :: twentyfourth, ccross
  INTRINSIC SQRT
  REAL*8 :: result1
  REAL*8 :: result1d
  REAL*8 :: temp
! -----------------------------------------------------------------
!
  half = 0.5d0
  one = 1.d0
  twothird = 2.d0/3.d0
  cvm1 = one/cv
! Coef for grad o4
  denom = 1.d0/12.d0
  b1 = 8.d0*denom
  b2 = -denom
! Primitives
! for Sutherland
  result1 = SQRT(tref)
  betas = muref*(tref+cs)/(result1*tref)
  pd = 0.0_8
  velxd = 0.0_8
  velyd = 0.0_8
  velzd = 0.0_8
  tlocd = 0.0_8
  mud = 0.0_8
  DO j=1-gh,jm+gh
!DIR$ IVDEP
    DO i=1-gh,im+gh
      rod = wd(i, j, 1)
      ro = w(i, j, 1)
      rom1d = -(one*rod/ro**2)
      rom1 = one/ro
      velxd(i, j) = rom1*wd(i, j, 2) + w(i, j, 2)*rom1d
      velx(i, j) = w(i, j, 2)*rom1
      velyd(i, j) = rom1*wd(i, j, 3) + w(i, j, 3)*rom1d
      vely(i, j) = w(i, j, 3)*rom1
      velzd(i, j) = rom1*wd(i, j, 4) + w(i, j, 4)*rom1d
      velz(i, j) = w(i, j, 4)*rom1
!
      ecd = half*(2*velx(i, j)*velxd(i, j)+2*vely(i, j)*velyd(i, j)+2*&
&       velz(i, j)*velzd(i, j))
      ec = half*(velx(i, j)*velx(i, j)+vely(i, j)*vely(i, j)+velz(i, j)*&
&       velz(i, j))
! ec  = HALF*( velx(i,j)*velx(i,j) &
!            + vely(i,j)*vely(i,j))
!
      temp = w(i, j, 5) - ec*ro
      elocd = rom1*(wd(i, j, 5)-ro*ecd-ec*rod) + temp*rom1d
      eloc = temp*rom1
!
      tlocd(i, j) = cvm1*elocd
      tloc(i, j) = eloc*cvm1
!
      pd(i, j) = (gam-one)*(eloc*rod+ro*elocd)
      p(i, j) = (gam-one)*ro*eloc
!  p(i,j)  = ro*rgaz*tloc(i,j)
!h(i,j,1)  = w(i,j,4)
!h(i,j,2)  = w(i,j,4) * velx(i,j)
!h(i,j,3)  = w(i,j,4) * vely(i,j)
!h(i,j,4)  = w(i,j,4) * velz(i,j) + p(i,j)
!h(i,j,5)  = w(i,j,4) * htot
      temp = SQRT(tloc(i, j))
      IF (tloc(i, j) .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = tlocd(i, j)/(2.0*temp)
      END IF
      result1 = temp
      temp = result1*tloc(i, j)/(s_suth+tloc(i, j))
      mud(i, j) = betas*(tloc(i, j)*result1d+(result1-temp)*tlocd(i, j))&
&       /(s_suth+tloc(i, j))
      mu(i, j) = betas*temp
    END DO
  END DO
  gradud = 0.0_8
  gradvd = 0.0_8
  gradwd = 0.0_8
! Work on interior domain minus one cell
  DO j=1,jm
!DIR$ IVDEP
    DO i=1,im
!idir
      guid = b1*(velxd(i+1, j)-velxd(i-1, j)) + b2*(velxd(i+2, j)-velxd(&
&       i-2, j))
      gui = b1*(velx(i+1, j)-velx(i-1, j)) + b2*(velx(i+2, j)-velx(i-2, &
&       j))
      gvid = b1*(velyd(i+1, j)-velyd(i-1, j)) + b2*(velyd(i+2, j)-velyd(&
&       i-2, j))
      gvi = b1*(vely(i+1, j)-vely(i-1, j)) + b2*(vely(i+2, j)-vely(i-2, &
&       j))
      gwid = b1*(velzd(i+1, j)-velzd(i-1, j)) + b2*(velzd(i+2, j)-velzd(&
&       i-2, j))
      gwi = b1*(velz(i+1, j)-velz(i-1, j)) + b2*(velz(i+2, j)-velz(i-2, &
&       j))
!jdir
      gujd = b1*(velxd(i, j+1)-velxd(i, j-1)) + b2*(velxd(i, j+2)-velxd(&
&       i, j-2))
      guj = b1*(velx(i, j+1)-velx(i, j-1)) + b2*(velx(i, j+2)-velx(i, j-&
&       2))
      gvjd = b1*(velyd(i, j+1)-velyd(i, j-1)) + b2*(velyd(i, j+2)-velyd(&
&       i, j-2))
      gvj = b1*(vely(i, j+1)-vely(i, j-1)) + b2*(vely(i, j+2)-vely(i, j-&
&       2))
      gwjd = b1*(velzd(i, j+1)-velzd(i, j-1)) + b2*(velzd(i, j+2)-velzd(&
&       i, j-2))
      gwj = b1*(velz(i, j+1)-velz(i, j-1)) + b2*(velz(i, j+2)-velz(i, j-&
&       2))
      volm1 = one/vol(i, j)
      dxm1 = half*(nx(i, j, 1)+nx(i+1, j, 1))*volm1
      dxm2 = half*(nx(i, j, 2)+nx(i, j+1, 2))*volm1
      dym1 = half*(ny(i, j, 1)+ny(i+1, j, 1))*volm1
      dym2 = half*(ny(i, j, 2)+ny(i, j+1, 2))*volm1
      gradud(i, j, 1) = dxm1*guid + dxm2*gujd
      gradu(i, j, 1) = dxm1*gui + dxm2*guj
      gradvd(i, j, 1) = dxm1*gvid + dxm2*gvjd
      gradv(i, j, 1) = dxm1*gvi + dxm2*gvj
      gradwd(i, j, 1) = dxm1*gwid + dxm2*gwjd
      gradw(i, j, 1) = dxm1*gwi + dxm2*gwj
      gradud(i, j, 2) = dym1*guid + dym2*gujd
      gradu(i, j, 2) = dym1*gui + dym2*guj
      gradvd(i, j, 2) = dym1*gvid + dym2*gvjd
      gradv(i, j, 2) = dym1*gvi + dym2*gvj
      gradwd(i, j, 2) = dym1*gwid + dym2*gwjd
      gradw(i, j, 2) = dym1*gwi + dym2*gwj
    END DO
  END DO
  func0d = 0.0_8
  func1d = 0.0_8
  func2d = 0.0_8
  func3d = 0.0_8
  func4d = 0.0_8
  func5d = 0.0_8
  func6d = 0.0_8
  func7d = 0.0_8
  func8d = 0.0_8
  func9d = 0.0_8
  func10d = 0.0_8
  func11d = 0.0_8
  func12d = 0.0_8
  func13d = 0.0_8
  func14d = 0.0_8
  func15d = 0.0_8
  DO j=1,jm
!DIR$ IVDEP
    DO i=1,im
!
      func0d(i, j, 1) = wd(i, j, 4)
      func0d(i, j, 2) = velz(i, j)*wd(i, j, 2) + w(i, j, 2)*velzd(i, j) &
&       - gradw(i, j, 1)*mud(i, j) - mu(i, j)*gradwd(i, j, 1)
      func0d(i, j, 3) = velz(i, j)*wd(i, j, 3) + w(i, j, 3)*velzd(i, j) &
&       - gradw(i, j, 2)*mud(i, j) - mu(i, j)*gradwd(i, j, 2)
      temp = gradu(i, j, 1) + gradv(i, j, 2)
      func0d(i, j, 4) = velz(i, j)*wd(i, j, 4) + w(i, j, 4)*velzd(i, j) &
&       + pd(i, j) + twothird*(temp*mud(i, j)+mu(i, j)*(gradud(i, j, 1)+&
&       gradvd(i, j, 2)))
      temp = w(i, j, 5) + p(i, j)
      func0d(i, j, 5) = velz(i, j)*(wd(i, j, 5)+pd(i, j)) + temp*velzd(i&
&       , j)
      func1d(i, j, 1) = 0.0_8
      func1d(i, j, 2) = velzd(i, j)
      func1d(i, j, 3) = velzd(i, j)
      func1d(i, j, 4) = velxd(i, j)
      func1d(i, j, 5) = velzd(i, j)
      func2d(i, j, 1) = 0.0_8
      func2d(i, j, 2) = gradwd(i, j, 1)
      func2d(i, j, 3) = gradwd(i, j, 2)
      func2d(i, j, 4) = velyd(i, j)
      func2d(i, j, 5) = gradwd(i, j, 1)
      func3d(i, j, 1) = 0.0_8
      func3d(i, j, 2) = 0.0_8
      func3d(i, j, 3) = 0.0_8
      func3d(i, j, 4) = gradud(i, j, 1) + gradvd(i, j, 2)
      func3d(i, j, 5) = velxd(i, j)
      func4d(i, j, 1) = 0.0_8
      func4d(i, j, 2) = 0.0_8
      func4d(i, j, 3) = 0.0_8
      func4d(i, j, 4) = 0.0_8
      func4d(i, j, 5) = gradud(i, j, 1)
      func5d(i, j, 1) = 0.0_8
      func5d(i, j, 2) = 0.0_8
      func5d(i, j, 3) = 0.0_8
      func5d(i, j, 4) = 0.0_8
      func5d(i, j, 5) = velzd(i, j)
      func6d(i, j, 1) = 0.0_8
      func6d(i, j, 2) = 0.0_8
      func6d(i, j, 3) = 0.0_8
      func6d(i, j, 4) = 0.0_8
      func6d(i, j, 5) = gradwd(i, j, 2)
      func7d(i, j, 1) = 0.0_8
      func7d(i, j, 2) = 0.0_8
      func7d(i, j, 3) = 0.0_8
      func7d(i, j, 4) = 0.0_8
      func7d(i, j, 5) = velyd(i, j)
      func8d(i, j, 1) = 0.0_8
      func8d(i, j, 2) = 0.0_8
      func8d(i, j, 3) = 0.0_8
      func8d(i, j, 4) = 0.0_8
      func8d(i, j, 5) = gradvd(i, j, 2)
      func9d(i, j, 1) = 0.0_8
      func9d(i, j, 2) = 0.0_8
      func9d(i, j, 3) = 0.0_8
      func9d(i, j, 4) = 0.0_8
      func9d(i, j, 5) = velxd(i, j)
      func10d(i, j, 1) = 0.0_8
      func10d(i, j, 2) = 0.0_8
      func10d(i, j, 3) = 0.0_8
      func10d(i, j, 4) = 0.0_8
      func10d(i, j, 5) = gradw(i, j, 1)*mud(i, j) + mu(i, j)*gradwd(i, j&
&       , 1)
      func11d(i, j, 1) = 0.0_8
      func11d(i, j, 2) = 0.0_8
      func11d(i, j, 3) = 0.0_8
      func11d(i, j, 4) = 0.0_8
      func11d(i, j, 5) = velyd(i, j)
      func12d(i, j, 1) = 0.0_8
      func12d(i, j, 2) = 0.0_8
      func12d(i, j, 3) = 0.0_8
      func12d(i, j, 4) = 0.0_8
      func12d(i, j, 5) = gradw(i, j, 2)*mud(i, j) + mu(i, j)*gradwd(i, j&
&       , 2)
      func13d(i, j, 1) = 0.0_8
      func13d(i, j, 2) = 0.0_8
      func13d(i, j, 3) = 0.0_8
      func13d(i, j, 4) = 0.0_8
      func13d(i, j, 5) = velzd(i, j)
      func14d(i, j, 1) = 0.0_8
      func14d(i, j, 2) = 0.0_8
      func14d(i, j, 3) = 0.0_8
      func14d(i, j, 4) = 0.0_8
!ZERO !mu(i,j)
      func14d(i, j, 5) = mud(i, j)
      func15d(i, j, 1) = 0.0_8
      func15d(i, j, 2) = 0.0_8
      func15d(i, j, 3) = 0.0_8
      func15d(i, j, 4) = 0.0_8
      func15d(i, j, 5) = gradud(i, j, 1) + gradvd(i, j, 2)
    END DO
  END DO
END SUBROUTINE FUNCTION_5P_DZ_D
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


subroutine coeffs_5p_dz(dz_out, &
& w, wd, x0, y0, nx, ny, xc, yc, vol, volf, gh, cp, cv, prandtl, gam, &
& rgaz, cs, muref, tref, s_suth, im, jm)
!
  implicit none
! variables for dimension -----------------------------------------
  integer :: im,jm,gh
! required arguments ----------------------------------------------
  real(8),intent(in) :: cp,cv,prandtl,gam,rgaz ! thermo
  real(8),intent(in) :: cs,muref,tref,s_suth ! viscosity
  real(8),dimension(1-gh:im+gh+1,1-gh:jm+gh+1      ),intent(in) :: x0
  real(8),dimension(1-gh:im+gh+1,1-gh:jm+gh+1      ),intent(in) :: y0
  real(8),dimension(1-gh:im+gh+1,1-gh:jm+gh+1, 2   ),intent(in) :: nx
  real(8),dimension(1-gh:im+gh+1,1-gh:jm+gh+1, 2   ),intent(in) :: ny
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ),intent(in) :: xc
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ),intent(in) :: yc
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ),intent(in) :: vol
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh  , 2   ),intent(in) :: volf
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh  , 5   ),intent(in) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5), INTENT(IN) :: wd
! Returned objects ------------------------------------------------
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh  , 5   ),intent(inout) :: dz_out
! Non-required arguments -------------------------------------------
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func0
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func0d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func1
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func1d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func2
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func2d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func3
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func3d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func4
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func4d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func5
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func5d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func6
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func6d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func7
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func7d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func8
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func8d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func9
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func9d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func10
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func10d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func11
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func11d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func12
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func12d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func13
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func13d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func14
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func14d
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func15
  REAL*8, DIMENSION(1:im, 1:jm, 5) :: func15d
  real(8),dimension(1:im, 1:jm, 5, 16) :: coeffs
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh  , 5   ) :: f,g
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ) :: velx
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ) :: vely
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ) :: velz
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ) :: tloc
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ) :: p
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh        ) :: mu
  real(8),dimension(1-gh:im+gh  ,1-gh:jm+gh     , 2) :: gradu,gradv,gradw,gradmu
  integer :: i,j,h
  real(8) :: nx_N, nx_S, nx_E, nx_O, volm1, ux,vx,wx,tx
  real(8) :: ny_N, ny_S, ny_E, ny_O, uy,vy,wy,ty
  real(8) :: val_N, val_S, val_E, val_O
  real(8) :: fxro1,fxro2, fxrou1,fxrou2,fxrov1,fxrov2,fxrow1,fxrow2,fxroe1,fxroe2
  real(8) :: dissro1,dissro2, dissrou1,dissrou2,dissrov1,dissrov2,dissrow1,dissrow2,dissroe1,dissroe2
  real(8) :: fvro1,fvro2, fvrou1,fvrou2,fvrov1,fvrov2,fvrow1,fvrow2,fvroe1,fvroe2
  real(8) :: gvro1,gvro2, gvrou1,gvrou2,gvrov1,gvrov2,gvrow1,gvrow2,gvroe1,gvroe2
  real(8) :: cpprandtl, mmu, lambda, uu, vv, ww, ro,rom1,htot,eloc,ec
  real(8) :: predro1,predrou1,predrov1,predrow1,predroe1, eps2,eps4
  real(8) :: predro2,predrou2,predrov2,predrow2,predroe2, rspec
  real(8) :: divu2,vort2,dx,dy,dxm1,dym1,dxm2,dym2
  real(8) :: gui,gvi,gwi,gmui
  real(8) :: guj,gvj,gwj,gmuj
  real(8) :: rhom,rhomr,rhoml,rhom1l,c2l,c2r,rr,r,u,ur,ul,vr,vl,wr,wl,c2x,nx2,ny2
  real(8) :: ab, sq,ducros1,ducros2,k_sensor1,k_sensor2
  real(8) :: b1,b2,b3,b4,b5,c1,c2,c3,c4,c5,wiggle, denom,betas
  real(8) :: nxloc, nyloc, sn, invsn, sc1, sc2
  real(8) :: d1, d2
  real(8) :: c3d0,c3d1
  real(8) :: pw,ct0,ct1,ct2,cvm1
  real(8) :: coef,omrr,test,diffro,diffrou,diffrov,diffrow,diffroe,v
  real(8) :: HALF,ONE,ZERO,TWO,TWOTHIRD,FOURTH,TWELFTH 
  real(8) :: TWENTYFOURTH,ccross
! -----------------------------------------------------------------
!
  HALF     = 0.5d0
  ONE      = 1.d0
  ZERO     = 0.d0
  TWO      = 2.d0
  TWOTHIRD = 2.d0/3.d0
  FOURTH   = 0.25d0
  TWELFTH  = 0.25d0/3.d0  
  TWENTYFOURTH = ONE/24.d0
  ccross = TWELFTH*0.0625d0
  
  cpprandtl = cp/prandtl
  cvm1      = ONE/cv 
   
! Coef for grad o4
  denom = 1.d0/12.d0
  
  b1 =  8.d0 * denom
  b2 = -       denom 
  
! Primitives
  betas = muref*(tref + cs)/(sqrt(tref)*tref) ! for Sutherland
  
!$AD II-LOOP
      do j=1-gh,jm+gh
!$AD II-LOOP
!DIR$ IVDEP
      do i=1-gh,im+gh

    ro = w(i,j,1)
    rom1 = ONE/ro
    velx(i,j) = w(i,j,2) * rom1
    vely(i,j) = w(i,j,3) * rom1
    velz(i,j) = w(i,j,4) * rom1
!
    ec  = HALF*( velx(i,j)*velx(i,j) &
               + vely(i,j)*vely(i,j) &
               + velz(i,j)*velz(i,j))

! ec  = HALF*( velx(i,j)*velx(i,j) &
!            + vely(i,j)*vely(i,j))
!
    eloc = (w(i,j,5) - ec*ro)*rom1
!
    tloc(i,j) = eloc*cvm1
!
    p(i,j)  = (gam-ONE)*ro*eloc
!  p(i,j)  = ro*rgaz*tloc(i,j)
    
    htot= (w(i,j,5) + p(i,j))*rom1
    
    f(i,j,1)  = w(i,j,2) 
    f(i,j,2)  = w(i,j,2) * velx(i,j) + p(i,j)
    f(i,j,3)  = w(i,j,2) * vely(i,j)
    f(i,j,4)  = w(i,j,2) * velz(i,j)
    f(i,j,5)  = w(i,j,2) * htot
    
    g(i,j,1)  = w(i,j,3) 
    g(i,j,2)  = w(i,j,3) * velx(i,j) 
    g(i,j,3)  = w(i,j,3) * vely(i,j) + p(i,j)
    g(i,j,4)  = w(i,j,3) * velz(i,j)
    g(i,j,5)  = w(i,j,3) * htot
    
!h(i,j,1)  = w(i,j,4)
!h(i,j,2)  = w(i,j,4) * velx(i,j)
!h(i,j,3)  = w(i,j,4) * vely(i,j)
!h(i,j,4)  = w(i,j,4) * velz(i,j) + p(i,j)
!h(i,j,5)  = w(i,j,4) * htot
    
        mu(i,j) = betas/(tloc(i,j) + s_suth) * sqrt(tloc(i,j)) * tloc(i,j)
    
    
  
      enddo
      enddo
  
  
! Work on interior domain minus one cell
  
!$AD II-LOOP
  do j = 1, jm
!DIR$ IVDEP
!$AD II-LOOP
  do i = 1, im
!idir
       gui   = ( b1*(velx(i+1,j     ) - velx(i-1,j     )) &
               + b2*(velx(i+2,j     ) - velx(i-2,j     )) )
       
       gvi   = ( b1*(vely(i+1,j     ) - vely(i-1,j     )) &
               + b2*(vely(i+2,j     ) - vely(i-2,j     )) )
       
       gwi   = ( b1*(velz(i+1,j     ) - velz(i-1,j     )) &
               + b2*(velz(i+2,j     ) - velz(i-2,j     )) )
                               
       gmui  = ( b1*(  mu(i+1,j     ) -   mu(i-1,j     )) &
               + b2*(  mu(i+2,j     ) -   mu(i-2,j     )) )
       
                           
       
!jdir
       guj   = ( b1*(velx(i,j+1   ) - velx(i,j-1   )) &
               + b2*(velx(i,j+2   ) - velx(i,j-2   )) )
       
       gvj   = ( b1*(vely(i,j+1   ) - vely(i,j-1   )) &
               + b2*(vely(i,j+2   ) - vely(i,j-2   )) )
       
       gwj   = ( b1*(velz(i,j+1   ) - velz(i,j-1   )) &
               + b2*(velz(i,j+2   ) - velz(i,j-2   )) )

       gmuj  = ( b1*(  mu(i,j+1   ) -   mu(i,j-1   )) &
               + b2*(  mu(i,j+2   ) -   mu(i,j-2   )) )
       
                           
       
      volm1 = ONE/vol(i,j)
      dxm1 = HALF*(nx(i,j,1)+nx(i+1,j  ,1))*volm1
      dxm2 = HALF*(nx(i,j,2)+nx(i  ,j+1,2))*volm1
      
      dym1 = HALF*(ny(i,j,1)+ny(i+1,j  ,1))*volm1
      dym2 = HALF*(ny(i,j,2)+ny(i  ,j+1,2))*volm1

       gradu( i,j,1)  = dxm1*gui   + dxm2*guj
       gradv( i,j,1)  = dxm1*gvi   + dxm2*gvj
       gradw( i,j,1)  = dxm1*gwi   + dxm2*gwj 
       gradmu(i,j,1)  = dxm1*gmui  + dxm2*gmuj
                         
       gradu( i,j,2)  = dym1*gui   + dym2*guj
       gradv( i,j,2)  = dym1*gvi   + dym2*gvj
       gradw( i,j,2)  = dym1*gwi   + dym2*gwj 
       gradmu(i,j,2)  = dym1*gmui  + dym2*gmuj
                         
                         
  enddo
  enddo
  
  
  
!$AD II-LOOP
  do j = 1 , jm 
!$AD II-LOOP
!DIR$ IVDEP
  do i = 1 , im 
!


    coeffs(i,j,1,1) = ONE
    coeffs(i,j,2,1) = ONE
    coeffs(i,j,3,1) = ONE
    coeffs(i,j,4,1) = ONE
    coeffs(i,j,5,1) = ONE

    coeffs(i,j,1,2) = ZERO
    coeffs(i,j,2,2) = TWOTHIRD * gradmu(i,j,1) !ZERO !TWOTHIRD * gradmu(i,j,1)
    coeffs(i,j,3,2) = TWOTHIRD * gradmu(i,j,2) !ZERO !TWOTHIRD * gradmu(i,j,2)
    coeffs(i,j,4,2) = - gradmu(i,j,1) !ZERO !- gradmu(i,j,1)
    coeffs(i,j,5,2) = TWOTHIRD * ( gradmu(i,j,1) * velx(i,j) + mu(i,j) * gradu(i,j,1) ) !TWOTHIRD*mu(i,j)*gradu(i,j,1) !TWOTHIRD * ( gradmu(i,j,1) * velx(i,j) + mu(i,j) * gradu(i,j,1) )

    coeffs(i,j,1,3) = ZERO
    coeffs(i,j,2,3) = TWOTHIRD * mu(i,j)
    coeffs(i,j,3,3) = TWOTHIRD * mu(i,j)
    coeffs(i,j,4,3) = - gradmu(i,j,2) !ZERO !- gradmu(i,j,2)
    coeffs(i,j,5,3) = TWOTHIRD * mu(i,j) * velx(i,j)

    coeffs(i,j,1,4) = ZERO
    coeffs(i,j,2,4) = ZERO
    coeffs(i,j,3,4) = ZERO
    coeffs(i,j,4,4) = - mu(i,j)
    coeffs(i,j,5,4) = - ( gradmu(i,j,1) * velz(i,j) + mu(i,j) * gradw(i,j,1) ) !-mu(i,j)*gradw(i,j,1) !- ( gradmu(i,j,1) * velz(i,j) + mu(i,j) * gradw(i,j,1) )

    coeffs(i,j,1,5) = ZERO
    coeffs(i,j,2,5) = ZERO
    coeffs(i,j,3,5) = ZERO
    coeffs(i,j,4,5) = ZERO
    coeffs(i,j,5,5) = - mu(i,j) * velz(i,j)

    coeffs(i,j,1,6) = ZERO
    coeffs(i,j,2,6) = ZERO
    coeffs(i,j,3,6) = ZERO
    coeffs(i,j,4,6) = ZERO
    coeffs(i,j,5,6) = TWOTHIRD * ( gradmu(i,j,2) * vely(i,j) + mu(i,j) * gradv(i,j,2) ) !TWOTHIRD*mu(i,j)*gradv(i,j,2) !TWOTHIRD * ( gradmu(i,j,2) * vely(i,j) + mu(i,j) * gradv(i,j,2) )

    coeffs(i,j,1,7) = ZERO
    coeffs(i,j,2,7) = ZERO
    coeffs(i,j,3,7) = ZERO
    coeffs(i,j,4,7) = ZERO
    coeffs(i,j,5,7) = TWOTHIRD * mu(i,j) * vely(i,j)

    coeffs(i,j,1,8) = ZERO
    coeffs(i,j,2,8) = ZERO
    coeffs(i,j,3,8) = ZERO
    coeffs(i,j,4,8) = ZERO
    coeffs(i,j,5,8) = - ( gradmu(i,j,2) * velz(i,j) + mu(i,j) * gradw(i,j,2) ) !-mu(i,j)*gradw(i,j,2) !- ( gradmu(i,j,2) * velz(i,j) + mu(i,j) * gradw(i,j,2) )

    coeffs(i,j,1,9) = ZERO
    coeffs(i,j,2,9) = ZERO
    coeffs(i,j,3,9) = ZERO
    coeffs(i,j,4,9) = ZERO
    coeffs(i,j,5,9) = - mu(i,j) * velz(i,j)

    coeffs(i,j,1,10) = ZERO
    coeffs(i,j,2,10) = ZERO
    coeffs(i,j,3,10) = ZERO
    coeffs(i,j,4,10) = ZERO
    coeffs(i,j,5,10) = - mu(i,j) * gradw(i,j,1)

    coeffs(i,j,1,11) = ZERO
    coeffs(i,j,2,11) = ZERO
    coeffs(i,j,3,11) = ZERO
    coeffs(i,j,4,11) = ZERO
    coeffs(i,j,5,11) = - velx(i,j)

    coeffs(i,j,1,12) = ZERO
    coeffs(i,j,2,12) = ZERO
    coeffs(i,j,3,12) = ZERO
    coeffs(i,j,4,12) = ZERO
    coeffs(i,j,5,12) = - mu(i,j) * gradw(i,j,2)

    coeffs(i,j,1,13) = ZERO
    coeffs(i,j,2,13) = ZERO
    coeffs(i,j,3,13) = ZERO
    coeffs(i,j,4,13) = ZERO
    coeffs(i,j,5,13) = - vely(i,j)

    coeffs(i,j,1,14) = ZERO
    coeffs(i,j,2,14) = ZERO
    coeffs(i,j,3,14) = ZERO
    coeffs(i,j,4,14) = ZERO
    coeffs(i,j,5,14) = TWOTHIRD * mu(i,j) * ( gradu(i,j,1) + gradv(i,j,2) )

    coeffs(i,j,1,15) = ZERO
    coeffs(i,j,2,15) = ZERO
    coeffs(i,j,3,15) = ZERO
    coeffs(i,j,4,15) = ZERO
    coeffs(i,j,5,15) = TWOTHIRD * velz(i,j) * ( gradu(i,j,1) + gradv(i,j,2) )

    coeffs(i,j,1,16) = ZERO
    coeffs(i,j,2,16) = ZERO
    coeffs(i,j,3,16) = ZERO
    coeffs(i,j,4,16) = ZERO
    coeffs(i,j,5,16) = TWOTHIRD * mu(i,j) * velz(i,j)


!
  enddo
  enddo


  call FUNCTION_5P_DZ_D(func0, func0d, func1, func1d, func2, func2d&
& , func3, func3d, func4, func4d, func5, func5d, func6, func6d, func7, &
& func7d, func8, func8d, func9, func9d, func10, func10d, func11, func11d&
& , func12, func12d, func13, func13d, func14, func14d, func15, func15d, &
& w, wd, x0, y0, nx, ny, xc, yc, vol, volf, gh, cp, cv, prandtl, gam, &
& rgaz, cs, muref, tref, s_suth, im, jm)

!$AD II-LOOP
  do j = 1 , jm 
!$AD II-LOOP
!DIR$ IVDEP
  do i = 1 , im 
!

  dz_out(i,j,1) = coeffs(i,j,1,1)  * func0d(i, j,  1)  + coeffs(i,j,1,2)  * func1d(i, j,  1) &
&               + coeffs(i,j,1,3)  * func2d(i, j,  1)  + coeffs(i,j,1,4)  * func3d(i, j,  1) &
&               + coeffs(i,j,1,5)  * func4d(i, j,  1)  + coeffs(i,j,1,6)  * func5d(i, j,  1) &
&               + coeffs(i,j,1,7)  * func6d(i, j,  1)  + coeffs(i,j,1,8)  * func7d(i, j,  1) &
&               + coeffs(i,j,1,9)  * func8d(i, j,  1)  + coeffs(i,j,1,10) * func9d(i, j,  1) &
&               + coeffs(i,j,1,11) * func10d(i, j, 1)  + coeffs(i,j,1,12) * func11d(i, j, 1) &
&               + coeffs(i,j,1,13) * func12d(i, j, 1)  + coeffs(i,j,1,14) * func13d(i, j, 1) &
&               + coeffs(i,j,1,15) * func14d(i, j, 1)  + coeffs(i,j,1,16) * func15d(i, j, 1)

  dz_out(i,j,2) = coeffs(i,j,2,1)  * func0d(i, j,  2)  + coeffs(i,j,2,2)  * func1d(i, j,  2) &
&               + coeffs(i,j,2,3)  * func2d(i, j,  2)  + coeffs(i,j,2,4)  * func3d(i, j,  2) &
&               + coeffs(i,j,2,5)  * func4d(i, j,  2)  + coeffs(i,j,2,6)  * func5d(i, j,  2) &
&               + coeffs(i,j,2,7)  * func6d(i, j,  2)  + coeffs(i,j,2,8)  * func7d(i, j,  2) &
&               + coeffs(i,j,2,9)  * func8d(i, j,  2)  + coeffs(i,j,2,10) * func9d(i, j,  2) &
&               + coeffs(i,j,2,11) * func10d(i, j, 2)  + coeffs(i,j,2,12) * func11d(i, j, 2) &
&               + coeffs(i,j,2,13) * func12d(i, j, 2)  + coeffs(i,j,2,14) * func13d(i, j, 2) &
&               + coeffs(i,j,2,15) * func14d(i, j, 2)  + coeffs(i,j,2,16) * func15d(i, j, 2)

  dz_out(i,j,3) = coeffs(i,j,3,1)  * func0d(i, j,  3)  + coeffs(i,j,3,2)  * func1d(i, j,  3) &
&               + coeffs(i,j,3,3)  * func2d(i, j,  3)  + coeffs(i,j,3,4)  * func3d(i, j,  3) &
&               + coeffs(i,j,3,5)  * func4d(i, j,  3)  + coeffs(i,j,3,6)  * func5d(i, j,  3) &
&               + coeffs(i,j,3,7)  * func6d(i, j,  3)  + coeffs(i,j,3,8)  * func7d(i, j,  3) &
&               + coeffs(i,j,3,9)  * func8d(i, j,  3)  + coeffs(i,j,3,10) * func9d(i, j,  3) &
&               + coeffs(i,j,3,11) * func10d(i, j, 3)  + coeffs(i,j,3,12) * func11d(i, j, 3) &
&               + coeffs(i,j,3,13) * func12d(i, j, 3)  + coeffs(i,j,3,14) * func13d(i, j, 3) &
&               + coeffs(i,j,3,15) * func14d(i, j, 3)  + coeffs(i,j,3,16) * func15d(i, j, 3)

  dz_out(i,j,4) = coeffs(i,j,4,1)  * func0d(i, j,  4)  + coeffs(i,j,4,2)  * func1d(i, j,  4) &
&               + coeffs(i,j,4,3)  * func2d(i, j,  4)  + coeffs(i,j,4,4)  * func3d(i, j,  4) &
&               + coeffs(i,j,4,5)  * func4d(i, j,  4)  + coeffs(i,j,4,6)  * func5d(i, j,  4) &
&               + coeffs(i,j,4,7)  * func6d(i, j,  4)  + coeffs(i,j,4,8)  * func7d(i, j,  4) &
&               + coeffs(i,j,4,9)  * func8d(i, j,  4)  + coeffs(i,j,4,10) * func9d(i, j,  4) &
&               + coeffs(i,j,4,11) * func10d(i, j, 4)  + coeffs(i,j,4,12) * func11d(i, j, 4) &
&               + coeffs(i,j,4,13) * func12d(i, j, 4)  + coeffs(i,j,4,14) * func13d(i, j, 4) &
&               + coeffs(i,j,4,15) * func14d(i, j, 4)  + coeffs(i,j,4,16) * func15d(i, j, 4)

  dz_out(i,j,5) = coeffs(i,j,5,1)  * func0d(i, j,  5)  + coeffs(i,j,5,2)  * func1d(i, j,  5) &
&               + coeffs(i,j,5,3)  * func2d(i, j,  5)  + coeffs(i,j,5,4)  * func3d(i, j,  5) &
&               + coeffs(i,j,5,5)  * func4d(i, j,  5)  + coeffs(i,j,5,6)  * func5d(i, j,  5) &
&               + coeffs(i,j,5,7)  * func6d(i, j,  5)  + coeffs(i,j,5,8)  * func7d(i, j,  5) &
&               + coeffs(i,j,5,9)  * func8d(i, j,  5)  + coeffs(i,j,5,10) * func9d(i, j,  5) &
&               + coeffs(i,j,5,11) * func10d(i, j, 5)  + coeffs(i,j,5,12) * func11d(i, j, 5) &
&               + coeffs(i,j,5,13) * func12d(i, j, 5)  + coeffs(i,j,5,14) * func13d(i, j, 5) &
&               + coeffs(i,j,5,15) * func14d(i, j, 5)  + coeffs(i,j,5,16) * func15d(i, j, 5)


!
  enddo
  enddo


end subroutine coeffs_5p_dz
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
